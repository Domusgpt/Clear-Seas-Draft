const fs = require('fs');
const path = require('path');

const rootDir = path.resolve(__dirname, '..');

function collectHtmlFiles(dir) {
  return fs
    .readdirSync(dir)
    .filter((file) => file.endsWith('.html'))
    .map((file) => path.join(dir, file));
}

function isExternalReference(ref) {
  return /^(https?:|mailto:|tel:|#|data:|\.\/\/)/i.test(ref);
}

function normalizeRef(ref) {
  return ref.split('?')[0].split('#')[0];
}

function analyzeHtml(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  const dir = path.dirname(filePath);

  const referenceMap = new Map();
  const patterns = [
    { regex: /<script[^>]*\ssrc="([^"]+)"/gi, type: 'asset' },
    { regex: /<link[^>]*\shref="([^"]+)"/gi, type: 'asset' },
    { regex: /<img[^>]*\ssrc="([^"]+)"/gi, type: 'asset' },
    { regex: /<source[^>]*\ssrc="([^"]+)"/gi, type: 'asset' },
    { regex: /<video[^>]*\ssrc="([^"]+)"/gi, type: 'asset' },
    { regex: /<audio[^>]*\ssrc="([^"]+)"/gi, type: 'asset' },
    { regex: /data-background="([^"]+)"/gi, type: 'data' },
    { regex: /data-video="([^"]+)"/gi, type: 'data' },
  ];

  patterns.forEach(({ regex, type }) => {
    let match;
    while ((match = regex.exec(content)) !== null) {
      const value = match[1] ? match[1].trim() : '';
      if (!value) {
        continue;
      }
      if (type === 'data' && !/[./]/.test(value)) {
        continue;
      }
      if (!referenceMap.has(value)) {
        referenceMap.set(value, type);
      }
    }
  });

  const result = {
    file: path.relative(rootDir, filePath),
    missing: [],
    present: [],
  };

  for (const [ref] of referenceMap) {
    if (!ref || isExternalReference(ref)) {
      continue;
    }

    const normalizedRef = normalizeRef(ref);
    const resolvedPath = path.resolve(dir, normalizedRef);
    const relPath = path.relative(rootDir, resolvedPath);

    if (fs.existsSync(resolvedPath)) {
      result.present.push(relPath);
    } else {
      result.missing.push({ ref, relPath });
    }
  }

  result.present.sort();
  result.missing.sort((a, b) => a.relPath.localeCompare(b.relPath));
  return result;
}

function buildReport() {
  const htmlFiles = collectHtmlFiles(rootDir);
  const results = htmlFiles.map(analyzeHtml);
  results.sort((a, b) => a.file.localeCompare(b.file));

  const lines = [];
  lines.push('# HTML Smoke Test Report');
  lines.push('');
  const timestamp = new Date().toISOString();
  lines.push(`_Generated: ${timestamp}_`);
  lines.push('');
  lines.push('This report checks each HTML file for broken local asset references (scripts, stylesheets, images, and media).');
  lines.push('External URLs, data URIs, and fragment links are ignored.');
  lines.push('');

  let totalFiles = 0;
  let passingFiles = 0;
  let failingFiles = 0;

  results.forEach((result) => {
    totalFiles += 1;
    if (result.missing.length === 0) {
      passingFiles += 1;
    } else {
      failingFiles += 1;
    }
  });

  lines.push('## Summary');
  lines.push('');
  lines.push(`- Total HTML files checked: **${totalFiles}**`);
  lines.push(`- Passing (no missing assets): **${passingFiles}**`);
  lines.push(`- Failing (missing assets detected): **${failingFiles}**`);
  lines.push('');

  results.forEach((result) => {
    lines.push(`### ${result.file}`);
    lines.push('');
    if (result.missing.length === 0) {
      lines.push('- ✅ All local assets resolved successfully.');
    } else {
      lines.push('- ❌ Missing assets detected:');
      result.missing.forEach((entry) => {
        lines.push(`  - \`${entry.ref}\` → _expected at_ \`${entry.relPath}\``);
      });
    }

    if (result.present.length > 0) {
      lines.push('');
      lines.push('  _Validated references:_');
      result.present.forEach((ref) => {
        lines.push(`  - ${ref}`);
      });
    }

    lines.push('');
  });

  lines.push('---');
  lines.push('');
  lines.push('Generated by `scripts/generate-html-test-report.js`.');

  fs.writeFileSync(path.join(rootDir, 'docs', 'html-test-report.md'), lines.join('\n'));
}

buildReport();
